"""
SQL Query Validator for E-commerce SQL Agent

This module validates SQL queries generated by the LLM to ensure they are safe
to execute. It checks for prohibited operations, validates syntax, and prevents
potential SQL injection attacks.

Author: SQL Agent Project
Date: July 19, 2025
"""

import re
import logging
from typing import List, Tuple, Optional
from models import ValidationResult
from settings import ALLOWED_SQL_OPERATIONS, MAX_QUERY_LENGTH

# Set up logging
logger = logging.getLogger(__name__)

# ============================================================================
# SQL VALIDATION CLASS
# ============================================================================

class SQLValidator:
    """
    Simple SQL validator for natural language generated queries
    
    This validator focuses on safety and basic validation:
    - Only allows SELECT operations
    - Prevents dangerous SQL keywords
    - Validates query structure
    - Checks query length limits
    """
    
    def __init__(self):
        """Initialize the SQL validator with security rules"""
        
        # Allowed SQL operations (from settings)
        self.allowed_operations = [op.upper() for op in ALLOWED_SQL_OPERATIONS]
        
        # Prohibited keywords that could be dangerous
        self.prohibited_keywords = [
            'DROP', 'DELETE', 'INSERT', 'UPDATE', 'ALTER', 'CREATE',
            'TRUNCATE', 'REPLACE', 'MERGE', 'GRANT', 'REVOKE',
            'EXEC', 'EXECUTE', 'CALL', 'DECLARE', 'SET'
        ]
        
        # Suspicious patterns that might indicate injection attempts
        self.suspicious_patterns = [
            r';.*--',           # Multiple statements with comments
            r'\bUNION\b.*\bSELECT\b',  # UNION-based injection
            r'1\s*=\s*1',       # Always true conditions
            r'OR\s+1\s*=\s*1',  # OR-based injection
            r'--\s*$',          # SQL comments at end
            r'/\*.*\*/',        # Block comments
        ]
        
        print("=" * 60)
        print("üõ°Ô∏è  SQL Validator Initialized")
        print(f"   Allowed operations: {', '.join(self.allowed_operations)}")
        print(f"   Max query length: {MAX_QUERY_LENGTH}")
        print("=" * 60)
    
    def validate_query(self, query: str) -> ValidationResult:
        """
        Validate a SQL query for safety and correctness
        
        Args:
            query (str): SQL query to validate
            
        Returns:
            ValidationResult: Validation result with success status and messages
        """
        print("=" * 60)
        print("üîç Validating SQL Query")
        print(f"   Query: {query[:80]}{'...' if len(query) > 80 else ''}")
        print("=" * 60)
        
        try:
            # Clean and normalize the query
            cleaned_query = self._clean_query(query)
            
            # Perform all validation checks
            validations = [
                self._check_query_length(cleaned_query),
                self._check_allowed_operations(cleaned_query),
                self._check_prohibited_keywords(cleaned_query),
                self._check_suspicious_patterns(cleaned_query),
                self._check_basic_syntax(cleaned_query)
            ]
            
            # Collect all errors and warnings
            errors = []
            warnings = []
            
            for is_valid, error_msg, warning_msg in validations:
                if not is_valid and error_msg:
                    errors.append(error_msg)
                if warning_msg:
                    warnings.append(warning_msg)
            
            # Determine overall validation result
            if errors:
                print(f"‚ùå Validation failed: {len(errors)} error(s)")
                for error in errors:
                    print(f"   ‚Ä¢ {error}")
                
                return ValidationResult(
                    is_valid=False,
                    error_message="; ".join(errors),
                    warnings=warnings
                )
            else:
                print("‚úÖ Query validation passed")
                if warnings:
                    print(f"‚ö†Ô∏è  {len(warnings)} warning(s):")
                    for warning in warnings:
                        print(f"   ‚Ä¢ {warning}")
                
                return ValidationResult(
                    is_valid=True,
                    error_message=None,
                    warnings=warnings
                )
                
        except Exception as e:
            error_msg = f"Validation error: {str(e)}"
            logger.error(error_msg)
            print(f"‚ùå {error_msg}")
            
            return ValidationResult(
                is_valid=False,
                error_message=error_msg,
                warnings=[]
            )
        
        finally:
            print("=" * 60)
    
    def _clean_query(self, query: str) -> str:
        """
        Clean and normalize the SQL query
        
        Args:
            query: Raw SQL query
            
        Returns:
            str: Cleaned query
        """
        # Remove extra whitespace and normalize
        cleaned = re.sub(r'\s+', ' ', query.strip())
        return cleaned
    
    def _check_query_length(self, query: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Check if query length is within limits
        
        Returns:
            Tuple: (is_valid, error_message, warning_message)
        """
        if len(query) > MAX_QUERY_LENGTH:
            return (
                False,
                f"Query too long ({len(query)} chars, max {MAX_QUERY_LENGTH})",
                None
            )
        
        if len(query) > MAX_QUERY_LENGTH * 0.8:  # Warning at 80% of limit
            return (
                True,
                None,
                f"Query is long ({len(query)} chars), consider simplifying"
            )
        
        return True, None, None
    
    def _check_allowed_operations(self, query: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Check if query uses only allowed operations
        
        Returns:
            Tuple: (is_valid, error_message, warning_message)
        """
        query_upper = query.upper()
        
        # Find the first keyword in the query
        first_word = query_upper.split()[0] if query_upper.split() else ""
        
        if first_word not in self.allowed_operations:
            return (
                False,
                f"Operation '{first_word}' not allowed. Only {', '.join(self.allowed_operations)} are permitted",
                None
            )
        
        return True, None, None
    
    def _check_prohibited_keywords(self, query: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Check for prohibited SQL keywords
        
        Returns:
            Tuple: (is_valid, error_message, warning_message)
        """
        query_upper = query.upper()
        
        found_prohibited = []
        for keyword in self.prohibited_keywords:
            # Use word boundaries to avoid false positives
            pattern = r'\b' + keyword + r'\b'
            if re.search(pattern, query_upper):
                found_prohibited.append(keyword)
        
        if found_prohibited:
            return (
                False,
                f"Prohibited keywords found: {', '.join(found_prohibited)}",
                None
            )
        
        return True, None, None
    
    def _check_suspicious_patterns(self, query: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Check for suspicious patterns that might indicate SQL injection
        
        Returns:
            Tuple: (is_valid, error_message, warning_message)
        """
        found_patterns = []
        
        for pattern in self.suspicious_patterns:
            if re.search(pattern, query, re.IGNORECASE):
                found_patterns.append(pattern)
        
        if found_patterns:
            return (
                False,
                "Query contains suspicious patterns that may indicate injection attempt",
                None
            )
        
        return True, None, None
    
    def _check_basic_syntax(self, query: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        Perform basic SQL syntax validation
        
        Returns:
            Tuple: (is_valid, error_message, warning_message)
        """
        warnings = []
        
        # Check for balanced parentheses
        if query.count('(') != query.count(')'):
            return (
                False,
                "Unbalanced parentheses in query",
                None
            )
        
        # Check for balanced quotes
        single_quotes = query.count("'")
        if single_quotes % 2 != 0:
            return (
                False,
                "Unmatched single quotes in query",
                None
            )
        
        # Basic SELECT structure check (for SELECT queries)
        if query.upper().startswith('SELECT'):
            if 'FROM' not in query.upper():
                warnings.append("SELECT query without FROM clause")
        
        return True, None, warnings[0] if warnings else None

# ============================================================================
# GLOBAL VALIDATOR INSTANCE
# ============================================================================

# Create global validator instance
print("=" * 60)
print("üõ°Ô∏è  Initializing SQL Validator")
print("=" * 60)

try:
    validator = SQLValidator()
    print("‚úÖ SQL Validator ready for use")
except Exception as e:
    print(f"‚ùå Failed to initialize SQL Validator: {e}")
    validator = None

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def validate_sql_query(query: str) -> ValidationResult:
    """
    Validate a SQL query using the global validator
    
    Args:
        query: SQL query to validate
        
    Returns:
        ValidationResult: Validation result
    """
    if not validator:
        return ValidationResult(
            is_valid=False,
            error_message="SQL Validator not initialized",
            warnings=[]
        )
    
    return validator.validate_query(query)

def is_query_safe(query: str) -> bool:
    """
    Quick check if a query is safe to execute
    
    Args:
        query: SQL query to check
        
    Returns:
        bool: True if query is safe, False otherwise
    """
    result = validate_sql_query(query)
    return result.is_valid

# ============================================================================
# EXPORT FUNCTIONS
# ============================================================================

__all__ = [
    'SQLValidator',
    'validate_sql_query',
    'is_query_safe'
]

# ============================================================================
# TEST FUNCTION
# ============================================================================

def test_validator():
    """Test function to verify validator works correctly"""
    print("=" * 80)
    print("üß™ TESTING SQL VALIDATOR")
    print("=" * 80)
    
    test_queries = [
        # Valid queries
        ("SELECT * FROM customers;", True),
        ("SELECT name, email FROM customers WHERE customer_id = 1;", True),
        ("SELECT COUNT(*) FROM orders;", True),
        
        # Invalid queries
        ("DROP TABLE customers;", False),
        ("DELETE FROM customers;", False),
        ("INSERT INTO customers VALUES (1, 'test');", False),
        ("SELECT * FROM customers; DROP TABLE orders;", False),
    ]
    
    for query, expected_valid in test_queries:
        result = validate_sql_query(query)
        status = "‚úÖ" if result.is_valid == expected_valid else "‚ùå"
        print(f"{status} Query: {query[:50]}... - Valid: {result.is_valid}")
        if result.error_message:
            print(f"    Error: {result.error_message}")
    
    print("=" * 80)

if __name__ == "__main__":
    test_validator()
