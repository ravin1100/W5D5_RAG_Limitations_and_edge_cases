"""
Pydantic Models for E-commerce SQL Agent API

This file defines the data models used for request/response validation
in the FastAPI backend. All models use Pydantic v2 syntax which is
compatible with the latest LangChain ecosystem.

Author: SQL Agent Project
Date: July 19, 2025
"""

from typing import Optional, List, Any, Dict
from datetime import datetime
from pydantic import BaseModel, Field, ConfigDict

# ============================================================================
# REQUEST MODELS - For incoming data to the API
# ============================================================================

class QueryRequest(BaseModel):
    """
    Model for natural language query requests from the frontend
    
    This is the main request model that the Streamlit frontend will send
    to the FastAPI backend with the user's natural language question.
    """
    model_config = ConfigDict(
        # Enable JSON schema generation
        json_schema_extra={
            "example": {
                "question": "Show all orders for customer John Doe",
                "user_id": "support_agent_1"
            }
        }
    )
    
    question: str = Field(
        ..., 
        min_length=3,
        max_length=500,
        description="Natural language question from the user"
    )
    user_id: Optional[str] = Field(
        default=None,
        description="ID of the user making the request (for logging/tracking)"
    )

# ============================================================================
# RESPONSE MODELS - For outgoing data from the API
# ============================================================================

class QueryResponse(BaseModel):
    """
    Main response model for SQL agent queries
    
    Contains the natural language answer, SQL query used, and metadata
    about the query execution process.
    """
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "success": True,
                "answer": "John Doe has 2 orders: Order #1 (pending, $79.98) and Order #8 (delivered, $45.99)",
                "sql_query": "SELECT * FROM orders o JOIN customers c ON o.customer_id = c.customer_id WHERE c.name = 'John Doe';",
                "row_count": 2,
                "execution_time": 0.45,
                "error_message": None
            }
        }
    )
    
    success: bool = Field(
        description="Whether the query was executed successfully"
    )
    answer: str = Field(
        description="Human-readable answer generated by the LLM"
    )
    sql_query: Optional[str] = Field(
        default=None,
        description="The SQL query that was generated and executed"
    )
    row_count: Optional[int] = Field(
        default=None,
        description="Number of rows returned by the query"
    )
    execution_time: Optional[float] = Field(
        default=None,
        description="Time taken to execute the query in seconds"
    )
    error_message: Optional[str] = Field(
        default=None,
        description="Error message if query failed"
    )

class ErrorResponse(BaseModel):
    """
    Standard error response model for API errors
    
    Used when something goes wrong during query processing
    """
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "success": False,
                "error_type": "SQL_VALIDATION_ERROR",
                "error_message": "Generated SQL contains prohibited operations",
                "details": "Only SELECT statements are allowed"
            }
        }
    )
    
    success: bool = Field(default=False)
    error_type: str = Field(description="Type of error that occurred")
    error_message: str = Field(description="Detailed error message")
    details: Optional[str] = Field(
        default=None,
        description="Additional details about the error"
    )

# ============================================================================
# DATABASE MODELS - For internal data representation
# ============================================================================

class Customer(BaseModel):
    """
    Customer data model matching the database schema
    """
    customer_id: int
    name: str
    email: str
    phone: Optional[str] = None
    address: Optional[str] = None
    created_at: datetime

class Product(BaseModel):
    """
    Product data model matching the database schema
    """
    product_id: int
    name: str
    category: str
    price: float
    stock_quantity: int
    description: Optional[str] = None
    created_at: datetime

class Order(BaseModel):
    """
    Order data model matching the database schema
    """
    order_id: int
    customer_id: int
    order_date: datetime
    status: str
    total_amount: float

class Review(BaseModel):
    """
    Review data model matching the database schema
    """
    review_id: int
    customer_id: int
    product_id: int
    rating: int = Field(ge=1, le=5)  # Must be between 1 and 5
    comment: Optional[str] = None
    created_at: datetime

class SupportTicket(BaseModel):
    """
    Support ticket data model matching the database schema
    """
    ticket_id: int
    customer_id: int
    subject: str
    description: str
    status: str
    priority: str
    created_at: datetime

# ============================================================================
# UTILITY MODELS - For various system operations
# ============================================================================

class SystemStatus(BaseModel):
    """
    Model for system health and status information
    """
    database_connected: bool = Field(description="Whether database connection is working")
    llm_available: bool = Field(description="Whether LLM service is available")
    total_queries_processed: Optional[int] = Field(
        default=None,
        description="Total number of queries processed since startup"
    )
    uptime_seconds: Optional[float] = Field(
        default=None,
        description="System uptime in seconds"
    )

class ValidationResult(BaseModel):
    """
    Model for SQL validation results
    
    Used internally by the SQL validator to return validation status
    """
    is_valid: bool = Field(description="Whether the SQL query is valid")
    error_message: Optional[str] = Field(
        default=None,
        description="Error message if validation failed"
    )
    warnings: Optional[List[str]] = Field(
        default_factory=list,
        description="Any warnings about the query"
    )

# ============================================================================
# LANGCHAIN INTEGRATION MODELS
# ============================================================================

class LLMRequest(BaseModel):
    """
    Model for requests to the LLM service
    
    Used internally when calling Gemini for SQL generation or response formatting
    """
    prompt: str = Field(description="The prompt to send to the LLM")
    temperature: Optional[float] = Field(
        default=0.1,
        ge=0.0,
        le=1.0,
        description="Temperature for LLM response (0.0 = deterministic, 1.0 = creative)"
    )
    max_tokens: Optional[int] = Field(
        default=2048,
        gt=0,
        description="Maximum number of tokens to generate"
    )

class LLMResponse(BaseModel):
    """
    Model for responses from the LLM service
    """
    content: str = Field(description="The generated content from the LLM")
    tokens_used: Optional[int] = Field(
        default=None,
        description="Number of tokens used in the response"
    )
    model_used: Optional[str] = Field(
        default=None,
        description="Which LLM model was used"
    )

# ============================================================================
# EXPORT ALL MODELS
# ============================================================================

__all__ = [
    # Request/Response models
    'QueryRequest',
    'QueryResponse', 
    'ErrorResponse',
    
    # Database models
    'Customer',
    'Product',
    'Order',
    'Review',
    'SupportTicket',
    
    # Utility models
    'SystemStatus',
    'ValidationResult',
    
    # LLM models
    'LLMRequest',
    'LLMResponse'
]

# ============================================================================
# SUCCESS MESSAGE
# ============================================================================
print("=" * 60)
print("âœ… Pydantic models loaded successfully!")
print(f"ðŸ“‹ Defined {len(__all__)} models for API operations")
print("ðŸ”§ Compatible with Pydantic v2 and latest LangChain")
print("=" * 60)
